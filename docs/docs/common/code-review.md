# Code Review 规范

---

## 1. 是什么

Code Review 的最大作用在于帮助团队找到代码缺陷。

1. 传播知识。在刚开始代码提交的过程中，不断 PR，不断 commit，最终才会被accepted。这个过程也是不断的 review 过程，通过同事之间的指导，能学到更多的代码规范和很多好的实践。

2. 增加代码质量。有经验的 coder 在架构设计、代码细节等方面会对新人有很好的帮助。Code Review也能帮助 coder 审视到自己的代码质量，以及实施最佳实践。Code Review 最核心的目的就是 code smell，目前公司前端团队代码一般很少经过单元测试&性能测试，经验丰富的同事能很快的发现 code smell，从而杜绝潜在 bug。

![](https://raw.githubusercontent.com/ittiam/guide/master/docs/assets/design/Experienced-Code-Reviewer.webp)

图源自(Code Review Checklist)[https://www.evoketechnologies.com/blog/code-review-checklist-perform-effective-code-reviews/]

## 2. Revivew 什么

### ① 代码风格：对团队既定规范的遵循

- 是否符合基本规范

### ② 架构设计：是否有整体设计，设计是否合理

- 如果有设计文档，是否按照设计文档思路来写代码
- 是否发现了更好的解决方案
- 提供了很好的解决思路

### ③ 代码：代码细节上是否尽可能保持简单和易读

- 是否明显重复代码
- 是否合理抽取枚举值，禁止使用“魔法值”
- 是否合理使用已有的组件和方法
- 对已有的、不合理的代码进行重构和优化
- 职责（组件、方法）、概念是否清晰

### ④ 健壮性：错误处理、业务逻辑的边界和基本的安全

- 边界和异常是否考虑完备
- 是否存在明显bug
- 是否考虑安全性（xss）

### ⑤ 效率：是否贡献了整体，为组件库和工具库添砖加瓦

- 是否抽取沉淀基础组件和通用业务组件到组件库

## 3. Review CheckList

### 3.1 HTML

| 启用标准模式 - 使用 HTML5 的 `doctype` 来启用标准模式 | ```<!DOCTYPE html>```                                        | 使用 HTML5 的 `doctype` 来启用标准模式  |
| ----------------------------------------------------- | ------------------------------------------------------------ | --------------------------------------- |
| 统一使用 `UTF-8` 编码                                 | ```<meta charset="UTF-8" />```                               |                                         |
| 移动设备添加 viewport                                 | ```<meta name="viewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />``` |                                         |
| 自闭合标签无需闭合                                    | ```<img src="https://xxx.png" alt="Google" /> <br /> <input type="text" name="title" />``` | 例如： `img`， `input`， `br`， `hr` 等 |
| 使用语义化标签                                        | ```<header></header> <footer></footer>```                    |                                         |

### 3.2 CSS

| BEM 命名原则         | ```.block__element { } .block--modifier { }``` |                                                              |
| -------------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 有效使用  CSS 选择器 | 见注1                                          | 选择器嵌套应少于 3 级                                        |
| 避免重绘重排         | 见注2、注3                                     | 当发生重排的时候，浏览器需要重新计算布局位置与大小，不利于性能优化。 |

注1: 有效使用 css 选择器，因遵循以下原则

- 保持简单，不要使用嵌套过多过于复杂的选择器。
- 通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。
- 不要使用类选择器和 ID 选择器修饰元素标签。
- 不要为了追求速度而放弃可读性与可维护性
- 避免使用 CSS 表达式

注2: 常见引起重绘重排属性和方法

- 添加或者删除可见的 `DOM` 元素；
- 元素尺寸改变——边距、填充、边框、宽度和高度
- 内容变化，比如用户在 `input` 框中输入文字
- 浏览器窗口尺寸改变——`resize` 事件发生时
- 计算 `offsetWidth` 和 `offsetHeight` 属性
- 设置 `style` 属性的值

注3: 减少重绘重排的方法

- 使用 `transform` 替代 `top`
- 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）
- 不要把节点的属性值放在一个循环里当成循环里的变量。
- 不要使用 `table` 布局，可能很小的一个小改动会造成整个 `table` 的重新布局
- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`
- CSS 选择符从右往左匹配查找，避免节点层级过多

### 3.3 JavaScript

| 命名                                         | 见注4                                                        | 命名采用小驼峰式命名 |
| -------------------------------------------- | ------------------------------------------------------------ | -------------------- |
| 字符串模板而不是 '+' 来拼接字符串            | `Hello,${world}`                                             |                      |
| 扩展运算符做数组浅拷贝                       | ```const copy = [...arr]```                                  |                      |
| 用 Array.from 去将一个类数组对象转成一个数组 | ```const arr = Array.from(arrLike)```                        |                      |
| 使用数组解构                                 | ```const [first, second] = arr```                            |                      |
| 对象浅拷贝时，更推荐使用扩展运算符 `...`     | `const copy = { ...original, c: 3 }`                         |                      |
| 函数参数使用默认值替代使用条件语句进行赋值   | ```function createMicrobrewery(name = 'Jack') {   ... }```   |                      |
| 优先使用 rest 语法 `...`，而不是 `arguments` | `function concatenateAll(...args) {  return args.join('') }` |                      |
| 尽量使用箭头函数                             | `[1, 2, 3].map((x) => {    const y = x + 1    return x * y  })` |                      |

注4: 命名需要符合语义化，如果函数命名，可以采用加上动词前缀：

- can 判断是否可执行某个动作
- has 判断是否含有某个值
- is 判断是否为某个值
- get 获取某个值
- set 设置某个值

### 3.4 Vue

| Prop 定义尽量详细，至少需要指定其类型 | ```props: {  status: String， required: true }```            |      |
| ------------------------------------- | ------------------------------------------------------------ | ---- |
| v-for 遍历必须添加 key                | ```<ul>  <li v-for="todo in todos" :key="todo.id">{{ todo.text }}</li> </ul>``` |      |
| v-if 和 v-for 不要用在同一个元素上    |                                                              |      |
| 组件模板应该书写简洁                  |                                                              |      |
| 指令缩写                              |                                                              |      |
| 多个属性进行分行                      |                                                              |      |
| 为组件样式设置作用域                  |                                                              |      |
| 清除定时器或者事件监听                |                                                              |      |
